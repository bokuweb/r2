use device_interfaces::TimerDriver;

/// Core-Local Interruptor (CLINT)
/// https://sifive.cdn.prismic.io/sifive%2Fc89f6e5a-cf9e-44c3-a3db-04420702dcc1_sifive+e31+manual+v19.08.pdf
/// https://chromitem-soc.readthedocs.io/en/latest/clint.html
#[derive(Debug, Default)]
pub struct Clint<T> {
    /// Machine-mode software interrupts are generated by writing to the memory-mapped control register msip
    /// The msip register is a 32-bit wide WARL register where the upper 31 bits are tied to 0.
    /// The least significant bit can be used to drive the MSIP bit of the mip CSR of a RISC-V hart.
    /// Other bits in the msip register are hardwired to zero. On reset, the msip register is cleared to zero.
    pub msip: u32,
    /// This is a read-write register and holds a 64-bit value.
    /// A timer interrupt is pending whenever mtime is greater than or equal to the value in the mtimecmp register.
    /// The timer interrupt is used to drive the MTIP bit of the mip CSR of a RISC-V core.
    pub mtimecmp: u64,
    /// mtime is a 64-bit read-write register that keeps track of the number of cycles counted from an arbitrary
    /// point in time. It is a free-running counter which is incremented every tick_count number of cycles
    pub mtime: u64,
    /// timer driver.
    timer: T,
}

impl<T: TimerDriver> Clint<T> {
    pub fn new(timer: T) -> Self {
        Self {
            msip: 0,
            mtimecmp: 0,
            mtime: 0,
            timer,
        }
    }

    pub fn step(&mut self, mip: &mut u32) {
        self.mtime += self.timer.as_micros();
        // Handle Elasped interrupt.
        if self.mtimecmp != 0 && self.mtime >= self.mtimecmp {
            *mip |= 0x80;
        } else {
            *mip &= !(0x80);
        }
    }

    /// Read register content.
    pub fn read(&self, addr: u32) -> u32 {
        match addr {
            // MSIP
            0x0000 => self.msip,
            // MTIMECMP
            0x4000 => self.mtimecmp as u32,
            0x4004 => self.mtimecmp.wrapping_shr(32) as u32,
            0xbff8 => self.mtime as u32,
            0xbffc => self.mtime.wrapping_shr(32) as u32,
            _ => unreachable!(),
        }
    }

    /// Write.
    pub fn write(&mut self, addr: u32, value: u32) {
        match addr {
            // MSIP
            0x0000 => self.msip = (self.msip & !0x1) | value & 1,
            // MTIMECMP
            0x4000 => self.mtimecmp = (self.mtimecmp & !0xffffffff) | (value as u64),
            0x4004 => {
                self.mtimecmp = (self.mtimecmp & !(0xffffffff << 32)) | ((value as u64) << 32)
            }
            // MTIME registers 8 bytes
            0xbff8 => self.mtime = (self.mtime & !0xffffffff) | (value as u64),
            0xbffc => self.mtime = (self.mtime & !(0xffffffff << 32)) | ((value as u64) << 32),
            _ => unreachable!(),
        };
    }
}
